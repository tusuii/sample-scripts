# K6 Performance Testing Guide for GKE Applications

## Table of Contents
1. [Introduction to K6](#introduction)
2. [Why K6 for Performance Testing](#why-k6)
3. [Installation and Setup](#installation)
4. [Basic K6 Concepts](#basic-concepts)
5. [Test Script Development](#test-scripts)
6. [Load Testing Patterns](#load-patterns)
7. [Stress Testing for 10,000 Users](#stress-testing)
8. [Running Tests on GKE](#gke-testing)
9. [Monitoring and Metrics](#monitoring)
10. [Report Generation](#reports)
11. [CI/CD Integration](#cicd)
12. [Best Practices](#best-practices)

## 1. Introduction to K6 {#introduction}

K6 is a modern load testing tool designed for developers and DevOps teams. It uses JavaScript ES6 for test scripts and provides excellent performance with minimal resource usage.

### Key Features:
- **Developer-friendly**: JavaScript-based test scripts
- **High performance**: Written in Go, handles thousands of VUs efficiently
- **Cloud-native**: Perfect for Kubernetes environments
- **Rich metrics**: Detailed performance insights
- **Multiple output formats**: JSON, InfluxDB, Prometheus, etc.

### Architecture Overview:
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   K6 Test       │    │   GKE Cluster   │    │   Monitoring    │
│   Runner        │───▶│   Application   │───▶│   Dashboard     │
│                 │    │                 │    │                 │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ Virtual     │ │    │ │ Microservice│ │    │ │ Grafana     │ │
│ │ Users (VUs) │ │    │ │ Pods        │ │    │ │ Prometheus  │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 2. Why K6 for Performance Testing {#why-k6}

### Advantages over Traditional Tools:

**vs JMeter:**
- Lighter resource usage (10x less memory)
- Better scripting with JavaScript
- Cloud-native design
- Faster execution

**vs Artillery:**
- More comprehensive metrics
- Better Kubernetes integration
- Superior reporting capabilities
- Enterprise features

**vs LoadRunner:**
- Open source and cost-effective
- Modern scripting approach
- Better CI/CD integration
- Container-friendly

### Performance Comparison:
```
Tool        | Memory Usage | VUs per GB RAM | Scripting
------------|--------------|----------------|----------
K6          | ~1-2MB/VU    | 500-1000      | JavaScript
JMeter      | ~10-15MB/VU  | 50-100        | GUI/XML
Artillery   | ~5-8MB/VU    | 100-200       | YAML/JS
LoadRunner  | ~8-12MB/VU   | 80-150        | C/JavaScript
```

## 3. Installation and Setup {#installation}

### Local Installation
```bash
# macOS
brew install k6

# Ubuntu/Debian
sudo gpg -k
sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
sudo apt-get update
sudo apt-get install k6

# Windows
choco install k6

# Docker
docker run --rm -i grafana/k6 run - <script.js
```

### Verify Installation
```bash
k6 version
```

### GKE Setup for K6
```yaml
# k6-namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: k6-testing
  labels:
    name: k6-testing
---
# k6-rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: k6-service-account
  namespace: k6-testing
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: k6-cluster-role
rules:
- apiGroups: [""]
  resources: ["pods", "services", "endpoints"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: k6-cluster-role-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: k6-cluster-role
subjects:
- kind: ServiceAccount
  name: k6-service-account
  namespace: k6-testing
```

## 4. Basic K6 Concepts {#basic-concepts}

### Virtual Users (VUs)
Virtual Users simulate real users interacting with your application.

```javascript
// Basic VU configuration
export let options = {
  vus: 10,        // 10 virtual users
  duration: '30s', // for 30 seconds
};
```

### Test Lifecycle
```javascript
// Setup code - runs once before test
export function setup() {
  console.log('Test setup');
  return { token: 'auth-token' };
}

// VU code - runs for each VU iteration
export default function(data) {
  // Main test logic
  http.get('https://api.example.com/users', {
    headers: { Authorization: `Bearer ${data.token}` }
  });
}

// Teardown code - runs once after test
export function teardown(data) {
  console.log('Test teardown');
}
```

### Metrics Types
```javascript
import { Counter, Rate, Trend, Gauge } from 'k6/metrics';

// Custom metrics
let errorRate = new Rate('error_rate');
let responseTime = new Trend('response_time');
let activeUsers = new Gauge('active_users');
let requestCount = new Counter('request_count');

export default function() {
  let response = http.get('https://api.example.com/health');
  
  // Record metrics
  errorRate.add(response.status !== 200);
  responseTime.add(response.timings.duration);
  requestCount.add(1);
  activeUsers.add(__VU);
}
```

## 5. Test Script Development {#test-scripts}

### Simple API Test
```javascript
// simple-api-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  vus: 50,
  duration: '5m',
};

export default function() {
  // Test GET endpoint
  let response = http.get('https://your-api.com/api/users');
  
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 500ms': (r) => r.timings.duration < 500,
    'has users data': (r) => r.json().length > 0,
  });
  
  sleep(1);
}
```

### Authentication Flow Test
```javascript
// auth-flow-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  vus: 100,
  duration: '10m',
};

export function setup() {
  // Get auth token
  let loginResponse = http.post('https://your-api.com/auth/login', {
    username: 'testuser',
    password: 'testpass'
  });
  
  return { token: loginResponse.json('token') };
}

export default function(data) {
  let params = {
    headers: {
      'Authorization': `Bearer ${data.token}`,
      'Content-Type': 'application/json',
    },
  };
  
  // Test protected endpoint
  let response = http.get('https://your-api.com/api/profile', params);
  
  check(response, {
    'authenticated request successful': (r) => r.status === 200,
    'profile data present': (r) => r.json('id') !== null,
  });
  
  sleep(2);
}
```

### Microservices End-to-End Test
```javascript
// microservices-e2e-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

// Custom metrics
let userServiceErrors = new Rate('user_service_errors');
let orderServiceErrors = new Rate('order_service_errors');
let paymentServiceErrors = new Rate('payment_service_errors');
let e2eResponseTime = new Trend('e2e_response_time');

export let options = {
  stages: [
    { duration: '2m', target: 100 },  // Ramp up
    { duration: '5m', target: 100 },  // Stay at 100 users
    { duration: '2m', target: 200 },  // Ramp up to 200
    { duration: '5m', target: 200 },  // Stay at 200
    { duration: '2m', target: 0 },    // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<2000'], // 95% of requests under 2s
    http_req_failed: ['rate<0.1'],     // Error rate under 10%
    e2e_response_time: ['p(90)<3000'], // 90% of E2E under 3s
  },
};

export default function() {
  let startTime = Date.now();
  
  // Step 1: Create user
  let userPayload = JSON.stringify({
    name: `User${__VU}`,
    email: `user${__VU}@test.com`
  });
  
  let userResponse = http.post('https://your-api.com/api/users', userPayload, {
    headers: { 'Content-Type': 'application/json' },
  });
  
  let userSuccess = check(userResponse, {
    'user created': (r) => r.status === 201,
  });
  userServiceErrors.add(!userSuccess);
  
  if (!userSuccess) return;
  
  let userId = userResponse.json('id');
  
  // Step 2: Create order
  let orderPayload = JSON.stringify({
    userId: userId,
    items: [
      { productId: 1, quantity: 2 },
      { productId: 2, quantity: 1 }
    ]
  });
  
  let orderResponse = http.post('https://your-api.com/api/orders', orderPayload, {
    headers: { 'Content-Type': 'application/json' },
  });
  
  let orderSuccess = check(orderResponse, {
    'order created': (r) => r.status === 201,
    'order has total': (r) => r.json('total') > 0,
  });
  orderServiceErrors.add(!orderSuccess);
  
  if (!orderSuccess) return;
  
  let orderId = orderResponse.json('id');
  
  // Step 3: Process payment
  let paymentPayload = JSON.stringify({
    orderId: orderId,
    amount: orderResponse.json('total'),
    paymentMethod: 'credit_card'
  });
  
  let paymentResponse = http.post('https://your-api.com/api/payments', paymentPayload, {
    headers: { 'Content-Type': 'application/json' },
  });
  
  let paymentSuccess = check(paymentResponse, {
    'payment processed': (r) => r.status === 200,
    'payment confirmed': (r) => r.json('status') === 'confirmed',
  });
  paymentServiceErrors.add(!paymentSuccess);
  
  // Record E2E response time
  e2eResponseTime.add(Date.now() - startTime);
  
  sleep(1);
}
```

### Database Load Test
```javascript
// database-load-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { SharedArray } from 'k6/data';

// Load test data
const testData = new SharedArray('test users', function() {
  return JSON.parse(open('./test-data.json'));
});

export let options = {
  vus: 200,
  duration: '15m',
  thresholds: {
    http_req_duration: ['p(95)<1000'],
    http_req_failed: ['rate<0.05'],
  },
};

export default function() {
  let user = testData[Math.floor(Math.random() * testData.length)];
  
  // Read operations (70% of traffic)
  if (Math.random() < 0.7) {
    let response = http.get(`https://your-api.com/api/users/${user.id}`);
    check(response, {
      'user data retrieved': (r) => r.status === 200,
      'user data valid': (r) => r.json('id') === user.id,
    });
  } 
  // Write operations (30% of traffic)
  else {
    let updatePayload = JSON.stringify({
      lastLogin: new Date().toISOString(),
      loginCount: user.loginCount + 1
    });
    
    let response = http.patch(`https://your-api.com/api/users/${user.id}`, updatePayload, {
      headers: { 'Content-Type': 'application/json' },
    });
    
    check(response, {
      'user updated': (r) => r.status === 200,
    });
  }
  
  sleep(Math.random() * 3 + 1); // 1-4 seconds think time
}
```
## 6. Load Testing Patterns {#load-patterns}

### Smoke Test (Minimal Load)
```javascript
// smoke-test.js
export let options = {
  vus: 1,
  duration: '1m',
  thresholds: {
    http_req_failed: ['rate<0.01'], // Less than 1% errors
    http_req_duration: ['p(95)<1000'], // 95% under 1s
  },
};

// Purpose: Verify system works with minimal load
```

### Load Test (Expected Load)
```javascript
// load-test.js
export let options = {
  stages: [
    { duration: '5m', target: 100 },  // Ramp up to normal load
    { duration: '10m', target: 100 }, // Stay at normal load
    { duration: '5m', target: 0 },    // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<2000'],
    http_req_failed: ['rate<0.05'],
  },
};

// Purpose: Test normal expected traffic
```

### Stress Test (Above Normal Load)
```javascript
// stress-test.js
export let options = {
  stages: [
    { duration: '2m', target: 100 },   // Normal load
    { duration: '5m', target: 100 },
    { duration: '2m', target: 200 },   // Above normal
    { duration: '5m', target: 200 },
    { duration: '2m', target: 300 },   // High load
    { duration: '5m', target: 300 },
    { duration: '2m', target: 400 },   // Breaking point
    { duration: '5m', target: 400 },
    { duration: '10m', target: 0 },    // Recovery
  ],
};

// Purpose: Find breaking point and recovery behavior
```

### Spike Test (Sudden Load Increase)
```javascript
// spike-test.js
export let options = {
  stages: [
    { duration: '10s', target: 100 },  // Normal load
    { duration: '1m', target: 100 },
    { duration: '10s', target: 1400 }, // Sudden spike
    { duration: '3m', target: 1400 },
    { duration: '10s', target: 100 },  // Back to normal
    { duration: '3m', target: 100 },
    { duration: '10s', target: 0 },
  ],
};

// Purpose: Test system behavior under sudden traffic spikes
```

### Volume Test (Large Data Sets)
```javascript
// volume-test.js
import { SharedArray } from 'k6/data';

const largeDataSet = new SharedArray('large dataset', function() {
  // Generate or load large dataset
  let data = [];
  for (let i = 0; i < 10000; i++) {
    data.push({
      id: i,
      name: `User${i}`,
      data: 'x'.repeat(1000) // 1KB of data per record
    });
  }
  return data;
});

export let options = {
  vus: 50,
  duration: '30m',
};

// Purpose: Test with large amounts of data
```

## 7. Stress Testing for 10,000 Users {#stress-testing}

### Infrastructure Requirements
```yaml
# k6-stress-test-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: k6-stress-test
  namespace: k6-testing
spec:
  replicas: 10  # Distribute load across multiple pods
  selector:
    matchLabels:
      app: k6-stress-test
  template:
    metadata:
      labels:
        app: k6-stress-test
    spec:
      serviceAccountName: k6-service-account
      containers:
      - name: k6
        image: grafana/k6:latest
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        env:
        - name: K6_PROMETHEUS_RW_SERVER_URL
          value: "http://prometheus:9090/api/v1/write"
        - name: K6_PROMETHEUS_RW_TREND_AS_NATIVE_HISTOGRAM
          value: "true"
        volumeMounts:
        - name: test-scripts
          mountPath: /scripts
        command: ["k6"]
        args: ["run", "--out", "prometheus", "/scripts/10k-users-test.js"]
      volumes:
      - name: test-scripts
        configMap:
          name: k6-test-scripts
---
apiVersion: v1
kind: Service
metadata:
  name: k6-stress-test-service
  namespace: k6-testing
spec:
  selector:
    app: k6-stress-test
  ports:
  - port: 6565
    targetPort: 6565
    name: k6-api
```

### 10K Users Test Script
```javascript
// 10k-users-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend, Counter } from 'k6/metrics';
import { SharedArray } from 'k6/data';

// Custom metrics for detailed reporting
let errorRate = new Rate('error_rate');
let responseTime = new Trend('response_time_ms');
let throughput = new Counter('requests_per_second');
let concurrentUsers = new Counter('concurrent_users');

// Load test data
const users = new SharedArray('users', function() {
  let userData = [];
  for (let i = 0; i < 10000; i++) {
    userData.push({
      id: i + 1,
      username: `user${i + 1}`,
      email: `user${i + 1}@test.com`
    });
  }
  return userData;
});

export let options = {
  scenarios: {
    // Scenario 1: Gradual ramp-up to 10K users
    stress_test: {
      executor: 'ramping-vus',
      stages: [
        { duration: '5m', target: 1000 },   // Ramp to 1K
        { duration: '5m', target: 2000 },   // Ramp to 2K
        { duration: '5m', target: 5000 },   // Ramp to 5K
        { duration: '10m', target: 10000 }, // Ramp to 10K
        { duration: '20m', target: 10000 }, // Sustain 10K
        { duration: '10m', target: 5000 },  // Ramp down to 5K
        { duration: '5m', target: 1000 },   // Ramp down to 1K
        { duration: '5m', target: 0 },      // Ramp down to 0
      ],
    },
    
    // Scenario 2: Spike test during sustained load
    spike_test: {
      executor: 'ramping-vus',
      startTime: '30m', // Start after main test is at 10K
      stages: [
        { duration: '30s', target: 2000 },  // Quick spike
        { duration: '2m', target: 2000 },   // Sustain spike
        { duration: '30s', target: 0 },     // Quick ramp down
      ],
    },
  },
  
  thresholds: {
    // Performance requirements
    http_req_duration: [
      'p(50)<1000',    // 50% under 1s
      'p(95)<3000',    // 95% under 3s
      'p(99)<5000',    // 99% under 5s
    ],
    http_req_failed: ['rate<0.1'],        // Less than 10% errors
    error_rate: ['rate<0.05'],            // Less than 5% custom errors
    response_time_ms: ['p(95)<2000'],     // 95% under 2s
    
    // Scenario-specific thresholds
    'http_req_duration{scenario:stress_test}': ['p(95)<3000'],
    'http_req_duration{scenario:spike_test}': ['p(95)<5000'],
  },
};

export function setup() {
  console.log('Starting 10K users stress test');
  console.log(`Test will run against: ${__ENV.TARGET_URL || 'https://your-api.com'}`);
  
  // Warm up the system
  let warmupResponse = http.get(`${__ENV.TARGET_URL || 'https://your-api.com'}/health`);
  console.log(`Warmup response: ${warmupResponse.status}`);
  
  return {
    baseUrl: __ENV.TARGET_URL || 'https://your-api.com',
    testStartTime: Date.now()
  };
}

export default function(data) {
  let user = users[(__VU - 1) % users.length];
  let startTime = Date.now();
  
  // Simulate realistic user behavior
  let scenario = Math.random();
  
  if (scenario < 0.4) {
    // 40% - Browse products/users
    browseContent(data, user);
  } else if (scenario < 0.7) {
    // 30% - Search functionality
    searchContent(data, user);
  } else if (scenario < 0.9) {
    // 20% - User profile operations
    userOperations(data, user);
  } else {
    // 10% - Heavy operations (orders, payments)
    heavyOperations(data, user);
  }
  
  // Record metrics
  let totalTime = Date.now() - startTime;
  responseTime.add(totalTime);
  throughput.add(1);
  concurrentUsers.add(__VU);
  
  // Realistic think time
  sleep(Math.random() * 3 + 1); // 1-4 seconds
}

function browseContent(data, user) {
  let response = http.get(`${data.baseUrl}/api/users?page=${Math.floor(Math.random() * 10) + 1}`);
  
  let success = check(response, {
    'browse users - status 200': (r) => r.status === 200,
    'browse users - response time OK': (r) => r.timings.duration < 2000,
    'browse users - has data': (r) => r.json().length > 0,
  });
  
  errorRate.add(!success);
  
  if (success && Math.random() < 0.3) {
    // 30% chance to view specific user
    let userId = Math.floor(Math.random() * 1000) + 1;
    let userResponse = http.get(`${data.baseUrl}/api/users/${userId}`);
    
    check(userResponse, {
      'view user - status 200': (r) => r.status === 200,
      'view user - response time OK': (r) => r.timings.duration < 1000,
    });
  }
}

function searchContent(data, user) {
  let searchTerm = `user${Math.floor(Math.random() * 100)}`;
  let response = http.get(`${data.baseUrl}/api/search?q=${searchTerm}&limit=20`);
  
  let success = check(response, {
    'search - status 200': (r) => r.status === 200,
    'search - response time OK': (r) => r.timings.duration < 3000,
  });
  
  errorRate.add(!success);
}

function userOperations(data, user) {
  // Login simulation
  let loginPayload = JSON.stringify({
    username: user.username,
    password: 'testpassword'
  });
  
  let loginResponse = http.post(`${data.baseUrl}/api/auth/login`, loginPayload, {
    headers: { 'Content-Type': 'application/json' },
  });
  
  let loginSuccess = check(loginResponse, {
    'login - status 200': (r) => r.status === 200,
    'login - has token': (r) => r.json('token') !== null,
  });
  
  if (loginSuccess) {
    let token = loginResponse.json('token');
    let headers = {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    };
    
    // Get user profile
    let profileResponse = http.get(`${data.baseUrl}/api/profile`, { headers });
    
    check(profileResponse, {
      'profile - status 200': (r) => r.status === 200,
      'profile - response time OK': (r) => r.timings.duration < 1500,
    });
    
    // Update profile (20% chance)
    if (Math.random() < 0.2) {
      let updatePayload = JSON.stringify({
        lastLogin: new Date().toISOString(),
        preferences: { theme: 'dark', notifications: true }
      });
      
      let updateResponse = http.patch(`${data.baseUrl}/api/profile`, updatePayload, { headers });
      
      check(updateResponse, {
        'profile update - status 200': (r) => r.status === 200,
      });
    }
  }
  
  errorRate.add(!loginSuccess);
}

function heavyOperations(data, user) {
  // Simulate order creation (resource intensive)
  let orderPayload = JSON.stringify({
    userId: user.id,
    items: [
      { productId: Math.floor(Math.random() * 100) + 1, quantity: Math.floor(Math.random() * 5) + 1 },
      { productId: Math.floor(Math.random() * 100) + 1, quantity: Math.floor(Math.random() * 3) + 1 }
    ],
    shippingAddress: {
      street: '123 Test St',
      city: 'Test City',
      zipCode: '12345'
    }
  });
  
  let orderResponse = http.post(`${data.baseUrl}/api/orders`, orderPayload, {
    headers: { 'Content-Type': 'application/json' },
  });
  
  let orderSuccess = check(orderResponse, {
    'order creation - status 201': (r) => r.status === 201,
    'order creation - response time OK': (r) => r.timings.duration < 5000,
    'order creation - has order ID': (r) => r.json('id') !== null,
  });
  
  errorRate.add(!orderSuccess);
  
  if (orderSuccess) {
    let orderId = orderResponse.json('id');
    
    // Simulate payment processing
    let paymentPayload = JSON.stringify({
      orderId: orderId,
      amount: orderResponse.json('total'),
      paymentMethod: 'credit_card',
      cardNumber: '4111111111111111'
    });
    
    let paymentResponse = http.post(`${data.baseUrl}/api/payments`, paymentPayload, {
      headers: { 'Content-Type': 'application/json' },
    });
    
    check(paymentResponse, {
      'payment - status 200': (r) => r.status === 200,
      'payment - response time OK': (r) => r.timings.duration < 10000,
    });
  }
}

export function teardown(data) {
  let testDuration = (Date.now() - data.testStartTime) / 1000;
  console.log(`Test completed in ${testDuration} seconds`);
  console.log('Generating final report...');
}
```

### Distributed Load Generation
```yaml
# k6-distributed-test.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: k6-distributed-load-test
  namespace: k6-testing
spec:
  parallelism: 5  # Run 5 pods in parallel
  completions: 5
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: k6-runner
        image: grafana/k6:latest
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        env:
        - name: K6_PROMETHEUS_RW_SERVER_URL
          value: "http://prometheus-server:80/api/v1/write"
        - name: TARGET_URL
          value: "https://your-gke-app.com"
        - name: VUS_PER_POD
          value: "2000"  # 2000 VUs per pod = 10K total
        command: ["k6"]
        args: [
          "run",
          "--vus", "$(VUS_PER_POD)",
          "--duration", "30m",
          "--out", "prometheus",
          "/scripts/distributed-test.js"
        ]
        volumeMounts:
        - name: test-scripts
          mountPath: /scripts
      volumes:
      - name: test-scripts
        configMap:
          name: k6-distributed-scripts
```

### Resource Monitoring During 10K Test
```yaml
# monitoring-stack.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-monitoring-config
  namespace: k6-testing
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
    scrape_configs:
    - job_name: 'k6'
      static_configs:
      - targets: ['k6-stress-test-service:6565']
    - job_name: 'kubernetes-pods'
      kubernetes_sd_configs:
      - role: pod
      relabel_configs:
      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
        action: keep
        regex: true
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus
  namespace: k6-testing
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      containers:
      - name: prometheus
        image: prom/prometheus:latest
        ports:
        - containerPort: 9090
        volumeMounts:
        - name: config
          mountPath: /etc/prometheus
        resources:
          requests:
            memory: "2Gi"
            cpu: "500m"
          limits:
            memory: "4Gi"
            cpu: "1000m"
      volumes:
      - name: config
        configMap:
          name: k6-monitoring-config
```
## 8. Running Tests on GKE {#gke-testing}

### GKE-Optimized Test Configuration
```javascript
// gke-optimized-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend } from 'k6/metrics';

// GKE-specific metrics
let podResponseTime = new Trend('pod_response_time');
let serviceDiscoveryTime = new Trend('service_discovery_time');
let ingressLatency = new Trend('ingress_latency');

export let options = {
  scenarios: {
    internal_traffic: {
      executor: 'ramping-vus',
      stages: [
        { duration: '5m', target: 1000 },
        { duration: '10m', target: 1000 },
        { duration: '5m', target: 0 },
      ],
      env: { TEST_TYPE: 'internal' },
    },
    external_traffic: {
      executor: 'ramping-vus',
      stages: [
        { duration: '5m', target: 500 },
        { duration: '10m', target: 500 },
        { duration: '5m', target: 0 },
      ],
      env: { TEST_TYPE: 'external' },
    },
  },
};

export default function() {
  let testType = __ENV.TEST_TYPE;
  let baseUrl;
  
  if (testType === 'internal') {
    // Test internal service communication
    baseUrl = 'http://user-service.default.svc.cluster.local:8080';
  } else {
    // Test through ingress/load balancer
    baseUrl = 'https://your-app.gke.example.com';
  }
  
  let startTime = Date.now();
  let response = http.get(`${baseUrl}/api/health`);
  let responseTime = Date.now() - startTime;
  
  check(response, {
    'status is 200': (r) => r.status === 200,
    'response time < 1000ms': (r) => r.timings.duration < 1000,
  });
  
  // Record GKE-specific metrics
  if (testType === 'internal') {
    podResponseTime.add(responseTime);
  } else {
    ingressLatency.add(responseTime);
  }
  
  sleep(1);
}
```

### Network Policy Testing
```javascript
// network-policy-test.js
import http from 'k6/http';
import { check } from 'k6';

export let options = {
  vus: 10,
  duration: '5m',
};

export default function() {
  // Test allowed connections
  let allowedResponse = http.get('http://user-service.default.svc.cluster.local:8080/api/users');
  check(allowedResponse, {
    'allowed connection works': (r) => r.status === 200,
  });
  
  // Test blocked connections (should fail)
  let blockedResponse = http.get('http://admin-service.admin.svc.cluster.local:8080/api/admin');
  check(blockedResponse, {
    'blocked connection fails': (r) => r.status === 0 || r.status >= 400,
  });
}
```

### HPA (Horizontal Pod Autoscaler) Testing
```javascript
// hpa-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';

export let options = {
  stages: [
    { duration: '2m', target: 50 },    // Baseline
    { duration: '5m', target: 200 },   // Trigger HPA
    { duration: '10m', target: 500 },  // Scale up more
    { duration: '5m', target: 1000 },  // Maximum scale
    { duration: '10m', target: 1000 }, // Sustain load
    { duration: '5m', target: 100 },   // Scale down
    { duration: '5m', target: 0 },     // Complete scale down
  ],
  thresholds: {
    http_req_duration: ['p(95)<3000'], // Allow higher latency during scaling
    http_req_failed: ['rate<0.15'],    // Allow higher error rate during scaling
  },
};

export default function() {
  // CPU-intensive endpoint to trigger HPA
  let response = http.post('http://your-service/api/cpu-intensive', JSON.stringify({
    iterations: 1000,
    data: 'x'.repeat(1000)
  }), {
    headers: { 'Content-Type': 'application/json' },
  });
  
  check(response, {
    'cpu intensive task completed': (r) => r.status === 200,
    'response time acceptable': (r) => r.timings.duration < 5000,
  });
  
  sleep(1);
}
```

## 9. Monitoring and Metrics {#monitoring}

### Comprehensive Monitoring Setup
```yaml
# k6-monitoring-stack.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-dashboards
  namespace: k6-testing
data:
  k6-dashboard.json: |
    {
      "dashboard": {
        "id": null,
        "title": "K6 Performance Testing Dashboard",
        "tags": ["k6", "performance"],
        "timezone": "browser",
        "panels": [
          {
            "id": 1,
            "title": "Virtual Users",
            "type": "graph",
            "targets": [
              {
                "expr": "k6_vus",
                "legendFormat": "Active VUs"
              },
              {
                "expr": "k6_vus_max",
                "legendFormat": "Max VUs"
              }
            ],
            "yAxes": [
              {
                "label": "Users",
                "min": 0
              }
            ]
          },
          {
            "id": 2,
            "title": "Request Rate",
            "type": "graph",
            "targets": [
              {
                "expr": "rate(k6_http_reqs_total[1m])",
                "legendFormat": "Requests/sec"
              }
            ]
          },
          {
            "id": 3,
            "title": "Response Time Percentiles",
            "type": "graph",
            "targets": [
              {
                "expr": "k6_http_req_duration{quantile=\"0.5\"}",
                "legendFormat": "P50"
              },
              {
                "expr": "k6_http_req_duration{quantile=\"0.95\"}",
                "legendFormat": "P95"
              },
              {
                "expr": "k6_http_req_duration{quantile=\"0.99\"}",
                "legendFormat": "P99"
              }
            ]
          },
          {
            "id": 4,
            "title": "Error Rate",
            "type": "graph",
            "targets": [
              {
                "expr": "rate(k6_http_reqs_total{status!~\"2..\"}[1m]) / rate(k6_http_reqs_total[1m]) * 100",
                "legendFormat": "Error Rate %"
              }
            ]
          },
          {
            "id": 5,
            "title": "Data Transfer",
            "type": "graph",
            "targets": [
              {
                "expr": "rate(k6_data_received_total[1m])",
                "legendFormat": "Data Received/sec"
              },
              {
                "expr": "rate(k6_data_sent_total[1m])",
                "legendFormat": "Data Sent/sec"
              }
            ]
          }
        ],
        "time": {
          "from": "now-1h",
          "to": "now"
        },
        "refresh": "5s"
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana
  namespace: k6-testing
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
      - name: grafana
        image: grafana/grafana:latest
        ports:
        - containerPort: 3000
        env:
        - name: GF_SECURITY_ADMIN_PASSWORD
          value: "admin123"
        volumeMounts:
        - name: dashboards
          mountPath: /var/lib/grafana/dashboards
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "200m"
      volumes:
      - name: dashboards
        configMap:
          name: grafana-dashboards
```

### Real-time Metrics Collection
```javascript
// real-time-metrics.js
import http from 'k6/http';
import { check } from 'k6';
import { Trend, Rate, Counter, Gauge } from 'k6/metrics';

// Business metrics
let userRegistrations = new Counter('user_registrations');
let orderCompletions = new Counter('order_completions');
let paymentFailures = new Rate('payment_failures');
let activeSessionsGauge = new Gauge('active_sessions');
let checkoutFunnelTime = new Trend('checkout_funnel_time');

// Infrastructure metrics
let databaseConnections = new Gauge('database_connections');
let cacheHitRate = new Rate('cache_hit_rate');
let queueLength = new Gauge('message_queue_length');

export let options = {
  vus: 100,
  duration: '30m',
  thresholds: {
    // Business SLAs
    user_registrations: ['count>1000'],
    order_completions: ['count>500'],
    payment_failures: ['rate<0.02'],
    checkout_funnel_time: ['p(95)<10000'],
    
    // Infrastructure SLAs
    cache_hit_rate: ['rate>0.8'],
    database_connections: ['value<100'],
  },
};

export default function() {
  // Simulate user journey with business metrics
  let journeyStart = Date.now();
  
  // User registration flow
  if (Math.random() < 0.1) { // 10% new users
    let registrationResponse = http.post('https://your-api.com/api/register', JSON.stringify({
      email: `user${__VU}@test.com`,
      password: 'testpass123'
    }), {
      headers: { 'Content-Type': 'application/json' },
    });
    
    if (check(registrationResponse, { 'registration successful': (r) => r.status === 201 })) {
      userRegistrations.add(1);
    }
  }
  
  // Shopping flow
  let productResponse = http.get('https://your-api.com/api/products?category=electronics');
  
  if (check(productResponse, { 'products loaded': (r) => r.status === 200 })) {
    // Add to cart
    let cartResponse = http.post('https://your-api.com/api/cart', JSON.stringify({
      productId: Math.floor(Math.random() * 100) + 1,
      quantity: Math.floor(Math.random() * 3) + 1
    }), {
      headers: { 'Content-Type': 'application/json' },
    });
    
    if (check(cartResponse, { 'added to cart': (r) => r.status === 200 })) {
      // Checkout process (20% conversion rate)
      if (Math.random() < 0.2) {
        let checkoutResponse = http.post('https://your-api.com/api/checkout', JSON.stringify({
          paymentMethod: 'credit_card',
          shippingAddress: '123 Test St'
        }), {
          headers: { 'Content-Type': 'application/json' },
        });
        
        let checkoutTime = Date.now() - journeyStart;
        checkoutFunnelTime.add(checkoutTime);
        
        if (check(checkoutResponse, { 'checkout successful': (r) => r.status === 200 })) {
          orderCompletions.add(1);
        } else {
          paymentFailures.add(1);
        }
      }
    }
  }
  
  // Update session gauge
  activeSessionsGauge.add(__VU);
  
  // Simulate infrastructure metrics (normally from monitoring endpoints)
  if (__ITER % 10 === 0) { // Every 10th iteration
    let metricsResponse = http.get('https://your-api.com/metrics');
    if (metricsResponse.status === 200) {
      let metrics = metricsResponse.json();
      databaseConnections.add(metrics.db_connections || 0);
      cacheHitRate.add(metrics.cache_hits / (metrics.cache_hits + metrics.cache_misses));
      queueLength.add(metrics.queue_length || 0);
    }
  }
}
```

## 10. Report Generation {#reports}

### Executive Summary Report Generator
```javascript
// report-generator.js
import { htmlReport } from 'https://raw.githubusercontent.com/benc-uk/k6-reporter/main/dist/bundle.js';
import { textSummary } from 'https://jslib.k6.io/k6-summary/0.0.1/index.js';

export function handleSummary(data) {
  return {
    'summary.html': htmlReport(data, {
      title: 'Performance Test Results - 10K Users Stress Test',
      description: 'Comprehensive performance analysis of microservices under extreme load',
    }),
    'summary.json': JSON.stringify(data, null, 2),
    'executive-summary.txt': generateExecutiveSummary(data),
    'detailed-report.html': generateDetailedReport(data),
    stdout: textSummary(data, { indent: ' ', enableColors: true }),
  };
}

function generateExecutiveSummary(data) {
  const metrics = data.metrics;
  const thresholds = data.thresholds;
  
  let summary = `
EXECUTIVE SUMMARY - PERFORMANCE TEST RESULTS
============================================

Test Overview:
- Test Duration: ${formatDuration(data.state.testRunDurationMs)}
- Peak Virtual Users: ${Math.max(...Object.values(metrics.vus?.values || {}))}
- Total Requests: ${metrics.http_reqs?.count || 0}
- Data Transferred: ${formatBytes(metrics.data_received?.count || 0)}

Key Performance Indicators:
---------------------------
✓ Average Response Time: ${(metrics.http_req_duration?.values?.avg || 0).toFixed(2)}ms
✓ 95th Percentile Response Time: ${(metrics.http_req_duration?.values?.['p(95)'] || 0).toFixed(2)}ms
✓ 99th Percentile Response Time: ${(metrics.http_req_duration?.values?.['p(99)'] || 0).toFixed(2)}ms
✓ Error Rate: ${((metrics.http_req_failed?.rate || 0) * 100).toFixed(2)}%
✓ Throughput: ${(metrics.http_reqs?.rate || 0).toFixed(2)} requests/second

System Performance:
------------------
${analyzePerformance(metrics)}

Threshold Results:
-----------------
${analyzeThresholds(thresholds)}

Recommendations:
---------------
${generateRecommendations(metrics, thresholds)}

Business Impact:
---------------
${calculateBusinessImpact(metrics)}
`;

  return summary;
}

function generateDetailedReport(data) {
  const metrics = data.metrics;
  
  return `
<!DOCTYPE html>
<html>
<head>
    <title>Detailed Performance Test Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .metric-card { border: 1px solid #ddd; padding: 20px; margin: 10px 0; border-radius: 5px; }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        .danger { background-color: #f8d7da; border-color: #f5c6cb; }
        .chart { width: 100%; height: 300px; margin: 20px 0; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>Performance Test Report - ${new Date().toISOString()}</h1>
    
    <div class="metric-card success">
        <h2>Test Summary</h2>
        <p><strong>Duration:</strong> ${formatDuration(data.state.testRunDurationMs)}</p>
        <p><strong>Virtual Users:</strong> ${Math.max(...Object.values(metrics.vus?.values || {}))}</p>
        <p><strong>Total Requests:</strong> ${metrics.http_reqs?.count || 0}</p>
        <p><strong>Success Rate:</strong> ${(100 - (metrics.http_req_failed?.rate || 0) * 100).toFixed(2)}%</p>
    </div>
    
    <div class="metric-card">
        <h2>Response Time Analysis</h2>
        <table>
            <tr><th>Metric</th><th>Value</th><th>Status</th></tr>
            <tr><td>Average</td><td>${(metrics.http_req_duration?.values?.avg || 0).toFixed(2)}ms</td><td>✓</td></tr>
            <tr><td>Median (P50)</td><td>${(metrics.http_req_duration?.values?.['p(50)'] || 0).toFixed(2)}ms</td><td>✓</td></tr>
            <tr><td>95th Percentile</td><td>${(metrics.http_req_duration?.values?.['p(95)'] || 0).toFixed(2)}ms</td><td>✓</td></tr>
            <tr><td>99th Percentile</td><td>${(metrics.http_req_duration?.values?.['p(99)'] || 0).toFixed(2)}ms</td><td>✓</td></tr>
            <tr><td>Maximum</td><td>${(metrics.http_req_duration?.values?.max || 0).toFixed(2)}ms</td><td>-</td></tr>
        </table>
    </div>
    
    <div class="metric-card">
        <h2>Throughput Analysis</h2>
        <p><strong>Requests per Second:</strong> ${(metrics.http_reqs?.rate || 0).toFixed(2)}</p>
        <p><strong>Data Received per Second:</strong> ${formatBytes(metrics.data_received?.rate || 0)}/s</p>
        <p><strong>Data Sent per Second:</strong> ${formatBytes(metrics.data_sent?.rate || 0)}/s</p>
    </div>
    
    <div class="metric-card ${getErrorRateClass(metrics.http_req_failed?.rate)}">
        <h2>Error Analysis</h2>
        <p><strong>Error Rate:</strong> ${((metrics.http_req_failed?.rate || 0) * 100).toFixed(2)}%</p>
        <p><strong>Failed Requests:</strong> ${metrics.http_req_failed?.fails || 0}</p>
        <p><strong>Successful Requests:</strong> ${(metrics.http_reqs?.count || 0) - (metrics.http_req_failed?.fails || 0)}</p>
    </div>
    
    ${generateCustomMetricsSection(metrics)}
    
    <div class="metric-card">
        <h2>Recommendations</h2>
        ${generateHTMLRecommendations(metrics)}
    </div>
    
</body>
</html>
`;
}

function analyzePerformance(metrics) {
  let analysis = [];
  
  const avgResponseTime = metrics.http_req_duration?.values?.avg || 0;
  const p95ResponseTime = metrics.http_req_duration?.values?.['p(95)'] || 0;
  const errorRate = metrics.http_req_failed?.rate || 0;
  const throughput = metrics.http_reqs?.rate || 0;
  
  if (avgResponseTime < 1000) {
    analysis.push('✓ Excellent average response time (<1s)');
  } else if (avgResponseTime < 2000) {
    analysis.push('⚠ Good average response time (1-2s)');
  } else {
    analysis.push('✗ Poor average response time (>2s)');
  }
  
  if (p95ResponseTime < 2000) {
    analysis.push('✓ Excellent 95th percentile response time (<2s)');
  } else if (p95ResponseTime < 5000) {
    analysis.push('⚠ Acceptable 95th percentile response time (2-5s)');
  } else {
    analysis.push('✗ Poor 95th percentile response time (>5s)');
  }
  
  if (errorRate < 0.01) {
    analysis.push('✓ Excellent error rate (<1%)');
  } else if (errorRate < 0.05) {
    analysis.push('⚠ Acceptable error rate (1-5%)');
  } else {
    analysis.push('✗ High error rate (>5%)');
  }
  
  if (throughput > 100) {
    analysis.push('✓ High throughput (>100 RPS)');
  } else if (throughput > 50) {
    analysis.push('⚠ Moderate throughput (50-100 RPS)');
  } else {
    analysis.push('✗ Low throughput (<50 RPS)');
  }
  
  return analysis.join('\n');
}

function generateRecommendations(metrics, thresholds) {
  let recommendations = [];
  
  const avgResponseTime = metrics.http_req_duration?.values?.avg || 0;
  const errorRate = metrics.http_req_failed?.rate || 0;
  const throughput = metrics.http_reqs?.rate || 0;
  
  if (avgResponseTime > 2000) {
    recommendations.push('• Consider optimizing database queries and adding caching');
    recommendations.push('• Review application code for performance bottlenecks');
    recommendations.push('• Consider horizontal scaling of application pods');
  }
  
  if (errorRate > 0.05) {
    recommendations.push('• Investigate error logs for root cause analysis');
    recommendations.push('• Implement circuit breakers and retry mechanisms');
    recommendations.push('• Review resource limits and requests for pods');
  }
  
  if (throughput < 50) {
    recommendations.push('• Scale up application replicas');
    recommendations.push('• Optimize resource allocation (CPU/Memory)');
    recommendations.push('• Consider using HPA for automatic scaling');
  }
  
  // Check failed thresholds
  Object.entries(thresholds || {}).forEach(([name, result]) => {
    if (!result.ok) {
      recommendations.push(`• Address failed threshold: ${name}`);
    }
  });
  
  if (recommendations.length === 0) {
    recommendations.push('• System performed well under load');
    recommendations.push('• Consider testing with higher load to find limits');
    recommendations.push('• Implement continuous performance monitoring');
  }
  
  return recommendations.join('\n');
}

function calculateBusinessImpact(metrics) {
  const totalRequests = metrics.http_reqs?.count || 0;
  const errorRate = metrics.http_req_failed?.rate || 0;
  const avgResponseTime = metrics.http_req_duration?.values?.avg || 0;
  
  // Simulate business calculations
  const estimatedUsers = totalRequests / 10; // Assume 10 requests per user session
  const lostUsers = estimatedUsers * errorRate;
  const revenuePerUser = 50; // $50 average revenue per user
  const potentialRevenueLoss = lostUsers * revenuePerUser;
  
  return `
• Estimated concurrent users handled: ${Math.floor(estimatedUsers)}
• Potential users lost due to errors: ${Math.floor(lostUsers)}
• Estimated revenue impact: $${potentialRevenueLoss.toFixed(2)}
• User experience rating: ${getUserExperienceRating(avgResponseTime, errorRate)}
• System can handle approximately ${Math.floor(estimatedUsers * 1.2)} users in production
`;
}

function getUserExperienceRating(avgResponseTime, errorRate) {
  if (avgResponseTime < 1000 && errorRate < 0.01) return 'Excellent';
  if (avgResponseTime < 2000 && errorRate < 0.05) return 'Good';
  if (avgResponseTime < 3000 && errorRate < 0.1) return 'Fair';
  return 'Poor';
}

// Helper functions
function formatDuration(ms) {
  const minutes = Math.floor(ms / 60000);
  const seconds = Math.floor((ms % 60000) / 1000);
  return `${minutes}m ${seconds}s`;
}

function formatBytes(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function getErrorRateClass(rate) {
  if (rate < 0.01) return 'success';
  if (rate < 0.05) return 'warning';
  return 'danger';
}

function analyzeThresholds(thresholds) {
  if (!thresholds) return 'No thresholds defined';
  
  let results = [];
  Object.entries(thresholds).forEach(([name, result]) => {
    const status = result.ok ? '✓' : '✗';
    results.push(`${status} ${name}: ${result.ok ? 'PASSED' : 'FAILED'}`);
  });
  
  return results.join('\n');
}
```
### Management Dashboard Setup
```yaml
# management-dashboard.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: management-dashboard
  namespace: k6-testing
data:
  dashboard.html: |
    <!DOCTYPE html>
    <html>
    <head>
        <title>Performance Testing Dashboard</title>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
            .container { max-width: 1200px; margin: 0 auto; }
            .card { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
            .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
            .metric-box { text-align: center; padding: 20px; border-radius: 8px; }
            .metric-value { font-size: 2em; font-weight: bold; margin: 10px 0; }
            .metric-label { color: #666; font-size: 0.9em; }
            .success { background: #d4edda; color: #155724; }
            .warning { background: #fff3cd; color: #856404; }
            .danger { background: #f8d7da; color: #721c24; }
            .chart-container { position: relative; height: 400px; margin: 20px 0; }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>Performance Testing Results - Executive Dashboard</h1>
            
            <div class="card">
                <h2>Key Performance Indicators</h2>
                <div class="metrics-grid">
                    <div class="metric-box success">
                        <div class="metric-value" id="throughput">0</div>
                        <div class="metric-label">Requests/Second</div>
                    </div>
                    <div class="metric-box success">
                        <div class="metric-value" id="response-time">0ms</div>
                        <div class="metric-label">Avg Response Time</div>
                    </div>
                    <div class="metric-box warning">
                        <div class="metric-value" id="error-rate">0%</div>
                        <div class="metric-label">Error Rate</div>
                    </div>
                    <div class="metric-box success">
                        <div class="metric-value" id="concurrent-users">0</div>
                        <div class="metric-label">Peak Concurrent Users</div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h2>Response Time Distribution</h2>
                <div class="chart-container">
                    <canvas id="responseTimeChart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h2>Load Pattern</h2>
                <div class="chart-container">
                    <canvas id="loadPatternChart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h2>System Capacity Analysis</h2>
                <div class="chart-container">
                    <canvas id="capacityChart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <h2>Business Impact Summary</h2>
                <div id="business-impact">
                    <p><strong>System Capacity:</strong> <span id="system-capacity">10,000 concurrent users</span></p>
                    <p><strong>Revenue Protection:</strong> <span id="revenue-protection">99.5% uptime maintained</span></p>
                    <p><strong>User Experience:</strong> <span id="user-experience">Excellent (sub-second response)</span></p>
                    <p><strong>Scalability:</strong> <span id="scalability">Ready for 2x traffic growth</span></p>
                </div>
            </div>
        </div>
        
        <script>
            // Initialize charts with sample data
            // In production, this would fetch real data from your monitoring system
            
            // Response Time Chart
            const responseTimeCtx = document.getElementById('responseTimeChart').getContext('2d');
            new Chart(responseTimeCtx, {
                type: 'line',
                data: {
                    labels: ['0min', '5min', '10min', '15min', '20min', '25min', '30min'],
                    datasets: [{
                        label: 'P50 Response Time',
                        data: [200, 250, 300, 280, 320, 290, 270],
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1
                    }, {
                        label: 'P95 Response Time',
                        data: [800, 900, 1200, 1100, 1300, 1150, 1000],
                        borderColor: 'rgb(255, 99, 132)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Response Time (ms)'
                            }
                        }
                    }
                }
            });
            
            // Load Pattern Chart
            const loadPatternCtx = document.getElementById('loadPatternChart').getContext('2d');
            new Chart(loadPatternCtx, {
                type: 'area',
                data: {
                    labels: ['0min', '5min', '10min', '15min', '20min', '25min', '30min'],
                    datasets: [{
                        label: 'Virtual Users',
                        data: [0, 2000, 5000, 8000, 10000, 10000, 0],
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Virtual Users'
                            }
                        }
                    }
                }
            });
            
            // Update metrics
            document.getElementById('throughput').textContent = '1,247';
            document.getElementById('response-time').textContent = '287ms';
            document.getElementById('error-rate').textContent = '0.3%';
            document.getElementById('concurrent-users').textContent = '10,000';
        </script>
    </body>
    </html>
---
apiVersion: v1
kind: Service
metadata:
  name: management-dashboard
  namespace: k6-testing
spec:
  selector:
    app: management-dashboard
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: management-dashboard
  namespace: k6-testing
spec:
  replicas: 1
  selector:
    matchLabels:
      app: management-dashboard
  template:
    metadata:
      labels:
        app: management-dashboard
    spec:
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: dashboard
          mountPath: /usr/share/nginx/html
      volumes:
      - name: dashboard
        configMap:
          name: management-dashboard
```

## 11. CI/CD Integration {#cicd}

### Jenkins Pipeline Integration
```groovy
// Jenkinsfile for K6 Performance Testing
pipeline {
    agent any
    
    environment {
        K6_VERSION = '0.45.0'
        GKE_CLUSTER = 'your-cluster-name'
        GKE_ZONE = 'us-central1-a'
        PROJECT_ID = 'your-project-id'
    }
    
    stages {
        stage('Setup') {
            steps {
                script {
                    // Install K6
                    sh '''
                        curl -s https://github.com/grafana/k6/releases/download/v${K6_VERSION}/k6-v${K6_VERSION}-linux-amd64.tar.gz | tar xvz
                        sudo mv k6-v${K6_VERSION}-linux-amd64/k6 /usr/local/bin/
                    '''
                    
                    // Configure kubectl
                    sh '''
                        gcloud container clusters get-credentials ${GKE_CLUSTER} \
                            --zone ${GKE_ZONE} \
                            --project ${PROJECT_ID}
                    '''
                }
            }
        }
        
        stage('Smoke Test') {
            steps {
                sh '''
                    k6 run --vus 1 --duration 30s \
                        --out json=smoke-test-results.json \
                        tests/smoke-test.js
                '''
                
                script {
                    def results = readJSON file: 'smoke-test-results.json'
                    if (results.metrics.http_req_failed.rate > 0.01) {
                        error('Smoke test failed - error rate too high')
                    }
                }
            }
        }
        
        stage('Load Test') {
            when {
                branch 'main'
            }
            steps {
                sh '''
                    k6 run --vus 100 --duration 10m \
                        --out json=load-test-results.json \
                        --out prometheus \
                        tests/load-test.js
                '''
                
                // Archive results
                archiveArtifacts artifacts: 'load-test-results.json', fingerprint: true
            }
        }
        
        stage('Stress Test') {
            when {
                anyOf {
                    branch 'main'
                    expression { params.RUN_STRESS_TEST == true }
                }
            }
            steps {
                script {
                    // Deploy K6 test to GKE for distributed load
                    sh '''
                        kubectl apply -f k8s/k6-stress-test.yaml
                        kubectl wait --for=condition=complete job/k6-stress-test --timeout=3600s
                        kubectl logs job/k6-stress-test > stress-test-results.log
                    '''
                    
                    // Generate reports
                    sh '''
                        k6 run --vus 1 --duration 1s \
                            --summary-export=stress-test-summary.json \
                            tests/report-generator.js
                    '''
                }
            }
            post {
                always {
                    // Cleanup
                    sh 'kubectl delete job k6-stress-test --ignore-not-found=true'
                    
                    // Archive results
                    archiveArtifacts artifacts: 'stress-test-*.*, *.html', fingerprint: true
                    
                    // Publish HTML reports
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: '.',
                        reportFiles: 'detailed-report.html',
                        reportName: 'Performance Test Report'
                    ])
                }
            }
        }
        
        stage('Performance Gate') {
            steps {
                script {
                    // Check performance thresholds
                    def results = readJSON file: 'load-test-results.json'
                    def avgResponseTime = results.metrics.http_req_duration.values.avg
                    def errorRate = results.metrics.http_req_failed.rate
                    
                    if (avgResponseTime > 2000) {
                        error("Performance gate failed: Average response time ${avgResponseTime}ms exceeds 2000ms threshold")
                    }
                    
                    if (errorRate > 0.05) {
                        error("Performance gate failed: Error rate ${errorRate * 100}% exceeds 5% threshold")
                    }
                    
                    echo "Performance gate passed ✓"
                }
            }
        }
    }
    
    post {
        always {
            // Send notifications
            script {
                def results = readJSON file: 'load-test-results.json'
                def avgResponseTime = results.metrics.http_req_duration.values.avg
                def errorRate = results.metrics.http_req_failed.rate * 100
                def throughput = results.metrics.http_reqs.rate
                
                emailext (
                    subject: "Performance Test Results - ${env.JOB_NAME} #${env.BUILD_NUMBER}",
                    body: """
                        Performance Test Completed
                        
                        Key Metrics:
                        - Average Response Time: ${avgResponseTime.toFixed(2)}ms
                        - Error Rate: ${errorRate.toFixed(2)}%
                        - Throughput: ${throughput.toFixed(2)} RPS
                        
                        View detailed report: ${env.BUILD_URL}Performance_Test_Report/
                    """,
                    to: "${env.CHANGE_AUTHOR_EMAIL},performance-team@company.com"
                )
            }
        }
        
        failure {
            slackSend(
                channel: '#performance-alerts',
                color: 'danger',
                message: "❌ Performance test failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}\nCheck: ${env.BUILD_URL}"
            )
        }
        
        success {
            slackSend(
                channel: '#performance-results',
                color: 'good',
                message: "✅ Performance test passed: ${env.JOB_NAME} #${env.BUILD_NUMBER}\nReport: ${env.BUILD_URL}Performance_Test_Report/"
            )
        }
    }
}
```

### GitHub Actions Integration
```yaml
# .github/workflows/performance-test.yml
name: Performance Testing

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * *'  # Daily at 2 AM
  workflow_dispatch:
    inputs:
      test_type:
        description: 'Type of test to run'
        required: true
        default: 'load'
        type: choice
        options:
        - smoke
        - load
        - stress
        - spike

jobs:
  performance-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Setup K6
      uses: grafana/setup-k6-action@v1
      with:
        k6-version: '0.45.0'
    
    - name: Setup GCloud
      uses: google-github-actions/setup-gcloud@v1
      with:
        service_account_key: ${{ secrets.GCP_SA_KEY }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}
    
    - name: Configure kubectl
      run: |
        gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER }} \
          --zone ${{ secrets.GKE_ZONE }} \
          --project ${{ secrets.GCP_PROJECT_ID }}
    
    - name: Run Smoke Test
      if: github.event_name == 'pull_request' || github.event.inputs.test_type == 'smoke'
      run: |
        k6 run --vus 1 --duration 30s \
          --out json=smoke-results.json \
          tests/smoke-test.js
    
    - name: Run Load Test
      if: github.ref == 'refs/heads/main' || github.event.inputs.test_type == 'load'
      run: |
        k6 run --vus 100 --duration 10m \
          --out json=load-results.json \
          tests/load-test.js
    
    - name: Run Stress Test
      if: github.event.inputs.test_type == 'stress' || github.event_name == 'schedule'
      run: |
        # Deploy distributed K6 test
        envsubst < k8s/k6-stress-test-template.yaml | kubectl apply -f -
        kubectl wait --for=condition=complete job/k6-stress-test --timeout=3600s
        kubectl logs job/k6-stress-test > stress-results.log
    
    - name: Generate Reports
      if: always()
      run: |
        # Generate HTML report
        k6 run --vus 1 --duration 1s tests/report-generator.js
        
        # Create summary for GitHub
        echo "## Performance Test Results" >> $GITHUB_STEP_SUMMARY
        echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
        echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
        
        if [ -f "load-results.json" ]; then
          RESULTS_FILE="load-results.json"
        elif [ -f "smoke-results.json" ]; then
          RESULTS_FILE="smoke-results.json"
        fi
        
        if [ -f "$RESULTS_FILE" ]; then
          AVG_RESPONSE=$(jq -r '.metrics.http_req_duration.values.avg' $RESULTS_FILE)
          ERROR_RATE=$(jq -r '.metrics.http_req_failed.rate * 100' $RESULTS_FILE)
          THROUGHPUT=$(jq -r '.metrics.http_reqs.rate' $RESULTS_FILE)
          
          echo "| Average Response Time | ${AVG_RESPONSE}ms |" >> $GITHUB_STEP_SUMMARY
          echo "| Error Rate | ${ERROR_RATE}% |" >> $GITHUB_STEP_SUMMARY
          echo "| Throughput | ${THROUGHPUT} RPS |" >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: Upload Reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: performance-reports
        path: |
          *.json
          *.html
          *.log
    
    - name: Performance Gate
      if: github.ref == 'refs/heads/main'
      run: |
        # Check performance thresholds
        if [ -f "load-results.json" ]; then
          AVG_RESPONSE=$(jq -r '.metrics.http_req_duration.values.avg' load-results.json)
          ERROR_RATE=$(jq -r '.metrics.http_req_failed.rate' load-results.json)
          
          if (( $(echo "$AVG_RESPONSE > 2000" | bc -l) )); then
            echo "❌ Performance gate failed: Average response time ${AVG_RESPONSE}ms exceeds 2000ms"
            exit 1
          fi
          
          if (( $(echo "$ERROR_RATE > 0.05" | bc -l) )); then
            echo "❌ Performance gate failed: Error rate ${ERROR_RATE} exceeds 5%"
            exit 1
          fi
          
          echo "✅ Performance gate passed"
        fi
    
    - name: Cleanup
      if: always()
      run: |
        kubectl delete job k6-stress-test --ignore-not-found=true
```

## 12. Best Practices {#best-practices}

### Test Design Best Practices

#### 1. Realistic Test Scenarios
```javascript
// realistic-user-behavior.js
import { check, sleep } from 'k6';
import http from 'k6/http';

export default function() {
  // Simulate realistic user behavior patterns
  let userType = Math.random();
  
  if (userType < 0.6) {
    // 60% - Casual browsers
    casualBrowsing();
  } else if (userType < 0.85) {
    // 25% - Active users
    activeUserBehavior();
  } else {
    // 15% - Power users
    powerUserBehavior();
  }
}

function casualBrowsing() {
  // Light usage pattern
  http.get('https://api.example.com/products');
  sleep(Math.random() * 10 + 5); // 5-15 seconds think time
  
  if (Math.random() < 0.3) { // 30% view details
    http.get('https://api.example.com/products/123');
    sleep(Math.random() * 5 + 2);
  }
}

function activeUserBehavior() {
  // Moderate usage pattern
  http.get('https://api.example.com/products');
  sleep(2);
  
  http.get('https://api.example.com/products/123');
  sleep(3);
  
  if (Math.random() < 0.5) { // 50% add to cart
    http.post('https://api.example.com/cart', JSON.stringify({
      productId: 123,
      quantity: 1
    }));
    sleep(1);
  }
}

function powerUserBehavior() {
  // Heavy usage pattern
  // Multiple API calls, complex operations
  let requests = [
    { method: 'GET', url: 'https://api.example.com/products' },
    { method: 'GET', url: 'https://api.example.com/categories' },
    { method: 'GET', url: 'https://api.example.com/recommendations' }
  ];
  
  http.batch(requests);
  sleep(1);
  
  // Complex transaction
  let response = http.post('https://api.example.com/orders', JSON.stringify({
    items: [
      { productId: 123, quantity: 2 },
      { productId: 456, quantity: 1 }
    ]
  }));
  
  if (response.status === 201) {
    http.post('https://api.example.com/payments', JSON.stringify({
      orderId: response.json('id'),
      amount: response.json('total')
    }));
  }
}
```

#### 2. Data Management
```javascript
// data-management.js
import { SharedArray } from 'k6/data';
import papaparse from 'https://jslib.k6.io/papaparse/5.1.1/index.js';

// Load test data efficiently
const users = new SharedArray('users', function() {
  return papaparse.parse(open('./test-data/users.csv'), { header: true }).data;
});

const products = new SharedArray('products', function() {
  return JSON.parse(open('./test-data/products.json'));
});

export default function() {
  // Use data efficiently
  let user = users[__VU % users.length];
  let product = products[Math.floor(Math.random() * products.length)];
  
  // Test with realistic data
  let response = http.post('https://api.example.com/orders', JSON.stringify({
    userId: user.id,
    productId: product.id,
    quantity: Math.floor(Math.random() * 5) + 1
  }));
}
```

#### 3. Environment Configuration
```javascript
// environment-config.js
const config = {
  development: {
    baseUrl: 'https://dev-api.example.com',
    vus: 10,
    duration: '5m',
    thresholds: {
      http_req_duration: ['p(95)<3000'],
      http_req_failed: ['rate<0.1'],
    }
  },
  staging: {
    baseUrl: 'https://staging-api.example.com',
    vus: 100,
    duration: '15m',
    thresholds: {
      http_req_duration: ['p(95)<2000'],
      http_req_failed: ['rate<0.05'],
    }
  },
  production: {
    baseUrl: 'https://api.example.com',
    vus: 1000,
    duration: '30m',
    thresholds: {
      http_req_duration: ['p(95)<1000'],
      http_req_failed: ['rate<0.01'],
    }
  }
};

const environment = __ENV.ENVIRONMENT || 'development';
export let options = config[environment];

export default function() {
  http.get(`${config[environment].baseUrl}/api/health`);
}
```

### Performance Testing Strategy

#### 1. Test Pyramid Approach
```
┌─────────────────────────────────────┐
│           Chaos Testing             │ ← 5% (Rare, high impact)
├─────────────────────────────────────┤
│          Stress Testing             │ ← 10% (Weekly/Monthly)
├─────────────────────────────────────┤
│           Load Testing              │ ← 25% (Regular, CI/CD)
├─────────────────────────────────────┤
│          Smoke Testing              │ ← 60% (Every deployment)
└─────────────────────────────────────┘
```

#### 2. Testing Schedule
```yaml
# testing-schedule.yaml
schedule:
  smoke_tests:
    frequency: "every deployment"
    duration: "1-2 minutes"
    vus: 1-5
    purpose: "Basic functionality verification"
  
  load_tests:
    frequency: "daily (CI/CD)"
    duration: "10-15 minutes"
    vus: 50-200
    purpose: "Expected load validation"
  
  stress_tests:
    frequency: "weekly"
    duration: "30-60 minutes"
    vus: 500-2000
    purpose: "Breaking point identification"
  
  endurance_tests:
    frequency: "monthly"
    duration: "2-8 hours"
    vus: 100-500
    purpose: "Memory leaks, stability"
  
  spike_tests:
    frequency: "before major releases"
    duration: "15-30 minutes"
    vus: "sudden spikes to 5000+"
    purpose: "Traffic surge handling"
```

### Key Success Metrics for 10K Users

#### Performance Targets
```yaml
performance_targets:
  response_time:
    p50: "<500ms"
    p95: "<2000ms"
    p99: "<5000ms"
  
  error_rate:
    target: "<1%"
    acceptable: "<5%"
    critical: ">10%"
  
  throughput:
    minimum: "1000 RPS"
    target: "2000 RPS"
    peak: "5000 RPS"
  
  resource_utilization:
    cpu: "<70%"
    memory: "<80%"
    network: "<60%"
  
  business_metrics:
    user_satisfaction: ">95%"
    conversion_rate: "maintained"
    revenue_impact: "<1% loss"
```

### Final Recommendations

1. **Start Small**: Begin with smoke tests, gradually increase complexity
2. **Realistic Scenarios**: Model actual user behavior patterns
3. **Continuous Testing**: Integrate into CI/CD pipeline
4. **Monitor Everything**: Track both technical and business metrics
5. **Automate Reports**: Generate executive-friendly dashboards
6. **Plan for Scale**: Design tests to grow with your application
7. **Document Results**: Maintain historical performance data
8. **Team Training**: Ensure team understands performance testing principles

This comprehensive guide provides everything needed to successfully implement K6 performance testing for your GKE applications, including the ability to stress test with 10,000 concurrent users and generate professional reports for management.
